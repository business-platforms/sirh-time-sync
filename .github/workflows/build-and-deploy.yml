name: Build and Deploy Multi-Environment Time Attendance System

on:
  push:
    branches: [dev, staging, master]
    paths:
      - 'version.txt'
      - 'version_dev.txt'
      - 'version_staging.txt'
      - 'src/**'
      - 'profiles/**'
      - '.github/**'

env:
  # Shared non-sensitive configuration
  SERVER_USER: "root"
  SERVER_BASE_PATH: "/root/sirh"

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      profile: ${{ steps.detect.outputs.profile }}
      version_file: ${{ steps.detect.outputs.version_file }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect Environment and Version
        id: detect
        run: |
          echo "üîç Detecting environment from branch: ${{ github.ref }}"
          
          if [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "profile=dev" >> $GITHUB_OUTPUT
            echo "version_file=version_dev.txt" >> $GITHUB_OUTPUT
            echo "üìç Detected: Development Environment"
            
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "profile=staging" >> $GITHUB_OUTPUT
            echo "version_file=version_staging.txt" >> $GITHUB_OUTPUT
            echo "üìç Detected: Staging Environment"
            
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "profile=prod" >> $GITHUB_OUTPUT
            echo "version_file=version.txt" >> $GITHUB_OUTPUT
            echo "üìç Detected: Production Environment"
            
          else
            echo "‚ùå Unknown branch: ${{ github.ref }}"
            exit 1
          fi

      - name: Read Version
        id: version
        run: |
          # Determine version file based on environment
          VERSION_FILE="${{ steps.detect.outputs.version_file }}"
          echo "üìÑ Using version file: $VERSION_FILE"
          
          # Fallback to main version.txt if profile-specific doesn't exist
          if [[ ! -f "$VERSION_FILE" ]]; then
            echo "‚ö†Ô∏è Profile-specific version file not found: $VERSION_FILE"
            echo "üìã Falling back to version.txt"
            VERSION_FILE="version.txt"
          fi
          
          if [[ ! -f "$VERSION_FILE" ]]; then
            echo "‚ùå No version file found!"
            exit 1
          fi
          
          VERSION=$(cat "$VERSION_FILE" | tr -d '[:space:]')
          PROFILE="${{ steps.detect.outputs.profile }}"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "profile=$PROFILE" >> $GITHUB_OUTPUT
          
          # Set installer name based on profile
          if [[ "$PROFILE" == "prod" ]]; then
            INSTALLER_NAME="timesync-setup-$VERSION.exe"
          else
            INSTALLER_NAME="timesync-setup-$PROFILE-$VERSION.exe"
          fi
          
          echo "installer_name=$INSTALLER_NAME" >> $GITHUB_OUTPUT
          
          echo "üìã Version: $VERSION"
          echo "üéØ Profile: $PROFILE"
          echo "üì¶ Installer: $INSTALLER_NAME"

      - name: Set Environment Variables
        run: |
          echo "VERSION=${{ steps.version.outputs.version }}" >> $GITHUB_ENV
          echo "PROFILE=${{ steps.detect.outputs.profile }}" >> $GITHUB_ENV
          echo "INSTALLER_NAME=${{ steps.version.outputs.installer_name }}" >> $GITHUB_ENV
          echo "LOCAL_INSTALLER_PATH=installer/${{ steps.version.outputs.installer_name }}" >> $GITHUB_ENV

  build-and-deploy:
    needs: detect-environment
    runs-on: windows-latest
    environment: ${{ needs.detect-environment.outputs.environment }}

    env:
      VERSION: ${{ needs.detect-environment.outputs.version }}
      PROFILE: ${{ needs.detect-environment.outputs.profile }}
      INSTALLER_NAME: ${{ needs.detect-environment.outputs.installer_name }}

    steps:
      - name: Environment Info
        run: |
          echo "üöÄ Starting Build for Environment: ${{ env.PROFILE }}"
          echo "üìã Version: ${{ env.VERSION }}"
          echo "üì¶ Installer: ${{ env.INSTALLER_NAME }}"

      - name: Checkout code
        uses: actions/checkout@v4

      # === SSH SETUP ===
      - name: Setup SSH key
        run: |
          echo "üîë Setting up SSH key for ${{ env.PROFILE }} for HOST: ${{ secrets.DEV_SERVER_HOST }}"
          mkdir -p ~/.ssh
          
          # Use environment-specific SSH key
          if [[ "${{ env.PROFILE }}" == "dev" ]]; then
            echo "${{ secrets.SSH_PRIVATE_KEY_DEV }}" > ~/.ssh/deploy_key
            SERVER_HOST="${{ secrets.DEV_SERVER_HOST }}"
          elif [[ "${{ env.PROFILE }}" == "staging" ]]; then
            echo "${{ secrets.SSH_PRIVATE_KEY_STAGING }}" > ~/.ssh/deploy_key
            SERVER_HOST="${{ secrets.STAGING_SERVER_HOST }}"
          elif [[ "${{ env.PROFILE }}" == "prod" ]]; then
            echo "${{ secrets.SSH_PRIVATE_KEY_PROD }}" > ~/.ssh/deploy_key
            SERVER_HOST="${{ secrets.PROD_SERVER_HOST }}"
          fi
          
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "$SERVER_HOST" >> ~/.ssh/known_hosts
          echo "SERVER_HOST=$SERVER_HOST" >> $GITHUB_ENV
          echo "‚úÖ SSH key configured for $SERVER_HOST"
        shell: bash

      - name: Get Environment Configuration
        run: |
          # Load profile configuration to get deployment details
          PROFILE_FILE="profiles/${{ env.PROFILE }}.json"
          
          if [[ ! -f "$PROFILE_FILE" ]]; then
            echo "‚ùå Profile file not found: $PROFILE_FILE"
            exit 1
          fi
          
          # Extract deployment configuration using jq
          SERVER_PATH=$(cat "$PROFILE_FILE" | jq -r '.deployment.server_path')
          
          echo "SERVER_PATH=$SERVER_PATH" >> $GITHUB_ENV
          echo "üóÇÔ∏è Deployment Path: $SERVER_PATH"
        shell: bash

      - name: Check existing version on server
        run: |
          echo "üîç Checking if version ${{ env.VERSION }} already exists on server..."
          
          CHECK_RESULT=$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "if [ -f ${{ env.SERVER_PATH }}/${{ env.INSTALLER_NAME }} ]; then echo 'EXISTS'; else echo 'NOT_EXISTS'; fi")
          
          if [[ "$CHECK_RESULT" == "EXISTS" ]]; then
            echo "‚ùå Version ${{ env.VERSION }} already exists on server."
            echo "To overwrite, delete the existing file first or use a different version."
            exit 1
          else
            echo "‚úÖ Version ${{ env.VERSION }} does not exist. Proceeding with build."
          fi
        shell: bash

      # === BUILD SECTION ===
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build installer with profile
        run: |
          echo "üî® Building installer for ${{ env.PROFILE }} environment..."
          python ci_build.py --version ${{ env.VERSION }} --profile ${{ env.PROFILE }}

      - name: Verify build output
        run: |
          echo "‚úÖ Checking build output..."
          if (Test-Path "${{ env.LOCAL_INSTALLER_PATH }}") {
            $fileSize = (Get-Item "${{ env.LOCAL_INSTALLER_PATH }}").Length
            $fileSizeMB = [math]::Round($fileSize / 1MB, 2)
            echo "‚úÖ Installer created: ${{ env.INSTALLER_NAME }} ($fileSizeMB MB)"
            echo "BUILD_SUCCESS=true" >> $env:GITHUB_ENV
          } else {
            echo "‚ùå Installer not found at: ${{ env.LOCAL_INSTALLER_PATH }}"
            exit 1
          }
        shell: pwsh

      # === DEPLOYMENT SECTION ===
      - name: Deploy installer to server
        run: |
          echo "üöÄ Deploying ${{ env.INSTALLER_NAME }} to ${{ env.PROFILE }} server..."
          
          # Copy file to server using SCP
          scp -i ~/.ssh/deploy_key "${{ env.LOCAL_INSTALLER_PATH }}" ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.SERVER_PATH }}/
          
          if [[ $? -eq 0 ]]; then
            echo "‚úÖ File uploaded successfully"
          else
            echo "‚ùå Upload failed"
            exit 1
          fi
        shell: bash

      - name: Set file permissions on server
        run: |
          echo "üîí Setting file permissions..."
          
          # Set proper permissions
          ssh -i ~/.ssh/deploy_key ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "chmod 644 ${{ env.SERVER_PATH }}/${{ env.INSTALLER_NAME }}"
          
          # Verify file was uploaded correctly
          REMOTE_SIZE=$(ssh -i ~/.ssh/deploy_key ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "stat -c%s ${{ env.SERVER_PATH }}/${{ env.INSTALLER_NAME }}")
          
          echo "‚úÖ Deployment successful: ${{ env.INSTALLER_NAME }} uploaded ($REMOTE_SIZE bytes)"
        shell: bash

      # === UPDATE SERVER VERSION MANAGEMENT ===
      - name: Update version file on server
        run: |
          echo "üìù Updating versions.json file on server..."
          
          # Get the appropriate app-data path for this environment
          if [[ "${{ env.PROFILE }}" == "dev" ]]; then
            APP_DATA_PATH="/root/sirh/time-sync/app-data"
          elif [[ "${{ env.PROFILE }}" == "staging" ]]; then
            APP_DATA_PATH="/root/sirh/time-sync-staging/app-data"
          elif [[ "${{ env.PROFILE }}" == "prod" ]]; then
            APP_DATA_PATH="/root/sirh/time-sync-prod/app-data"
          fi
          
          echo "üìÅ App Data Path: $APP_DATA_PATH"
          
          # Ensure app-data directory exists
          ssh -i ~/.ssh/deploy_key ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "mkdir -p $APP_DATA_PATH"
          
          # Create updated versions.json content
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          VERSION_JSON=$(cat << EOF
          {
            "latest": {
              "version": "${{ env.VERSION }}",
              "notes": "Automated release from GitHub Actions - ${{ env.PROFILE }} environment - $(date '+%Y-%m-%d %H:%M:%S')"
            },
            "versions": {
              "${{ env.VERSION }}": {
                "notes": "Automated release from GitHub Actions",
                "releaseDate": "$TIMESTAMP",
                "environment": "${{ env.PROFILE }}"
              }
            }
          }
          EOF
          )
          
          # Write updated versions.json to server
          ssh -i ~/.ssh/deploy_key ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "echo '$VERSION_JSON' > $APP_DATA_PATH/versions.json"
          
          # Verify the update
          echo "‚úÖ Verifying update..."
          UPDATED_CONTENT=$(ssh -i ~/.ssh/deploy_key ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "cat $APP_DATA_PATH/versions.json")
          echo "Updated versions.json: $UPDATED_CONTENT"
          
          echo "‚úÖ Version ${{ env.VERSION }} registered successfully in ${{ env.PROFILE }} environment"
        shell: bash

      # === CLEANUP ===
      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
        shell: bash

      - name: Upload build artifacts (backup)
        if: env.BUILD_SUCCESS == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: timesync-installer-${{ env.PROFILE }}-${{ env.VERSION }}
          path: installer/*.exe
          retention-days: 30

      # === SUMMARY ===
      - name: Deployment summary
        if: success()
        run: |
          echo "üéâ DEPLOYMENT COMPLETED SUCCESSFULLY!"
          echo "=================================="
          echo "üéØ Environment: ${{ env.PROFILE }}"
          echo "üìã Version: ${{ env.VERSION }}"
          echo "üìÅ Installer: ${{ env.INSTALLER_NAME }}"
          echo "üåê Server: ${{ env.SERVER_HOST }}"
          echo "üìÇ Path: ${{ env.SERVER_PATH }}"
          echo "‚è∞ Completed: $(date '+%Y-%m-%d %H:%M:%S')"
        shell: bash